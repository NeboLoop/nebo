---
name: app-creator
description: Create production-grade Nebo apps with gRPC services, manifest, and SKILL.md
version: "1.0.0"
author: Alma Tuck
priority: 40
triggers:
  - create an app
  - build an app
  - new app
  - app for
  - write an app
tools:
  - system
tags:
  - development
  - app-platform
metadata:
  nebo:
    emoji: "ðŸš€"
---

# App Creator

You are building production-grade Nebo apps from scratch. Your role is to generate working, deployable apps that integrate seamlessly with Nebo's agent platform.

## Core Principles

1. **Complete and functional** â€” Every app is buildable and deployable. No stubs, no pseudo-code. Generate working Go code.
2. **STRAP pattern always** â€” All tools use the Single Tool Resource Action Pattern. Never generate traditional multi-function APIs.
3. **Deny-by-default security** â€” Only declare permissions the app actually needs. Err on the side of restrictive.
4. **Proto-first schemas** â€” Use Nebo's built-in `SchemaBuilder` to generate JSON schemas matching the `.proto` definitions.
5. **SDK abstractions** â€” Let the SDK handle gRPC, lifecycle, signal handling, logging. Your code focuses on the handler interfaces.
6. **Testing before shipping** â€” Always include build instructions and verification steps.

## App Structure

Every app has this directory layout:
```
com.example.appname/
  manifest.json       # Required: app metadata + capabilities + permissions
  SKILL.md           # Required: how the agent should use this app
  main.go            # Implementation (or main.rs, app.c, etc.)
  go.mod, go.sum     # Dependencies (if Go)
  ui/                # Optional: static UI assets for settings panels
  data/              # Auto-created: sandboxed persistent storage
```

## Manifest Pattern

Always start with a minimal, valid manifest:

```json
{
    "id": "com.{domain}.{appname}",
    "name": "App Display Name",
    "version": "1.0.0",
    "description": "One-liner of what it does",
    "runtime": "local",
    "protocol": "grpc",
    "provides": ["tool:tool_name"],
    "permissions": []
}
```

Follow these rules:
- `id` is reverse-domain style: lowercase, no spaces or special chars
- `version` is semver
- `provides` should be a single capability for MVP â€” multi-capability comes later
- `permissions` should be empty initially â€” add only when actually needed
- Optional fields (`oauth`, `startup_timeout`, etc.) are omitted unless required

## Tool Implementation

### STRAP Schema

Use the SDK's `SchemaBuilder` to generate STRAP-compliant schemas:

```go
func (c *Calculator) Schema() json.RawMessage {
    return nebo.NewSchema("add", "subtract", "multiply", "divide").
        Number("a", "First operand", true).
        Number("b", "Second operand", true).
        Build()
}
```

The `NewSchema(actions...)` call:
- Args are the `action` enum values (e.g., `"add"`, `"subtract"`)
- Chain `.String(name, desc, required)`, `.Number(name, desc, required)`, `.Bool(name, desc, required)`, `.Enum(name, desc, required, values...)`, `.Object(name, desc, required)` to add parameters
- `.Build()` returns ready-to-use `json.RawMessage`

For multi-resource tools, add a `resource` enum field:

```go
return nebo.NewSchema("create", "list", "update", "delete").
    Enum("resource", "Resource type", true, "task", "milestone").
    String("title", "Task title", false).
    Build()
```

### Execute Pattern

All Execute handlers follow this pattern:

```go
func (c *YourTool) Execute(ctx context.Context, input json.RawMessage) (string, error) {
    var in struct {
        Action string `json:"action"`
        // ... other fields from schema
    }
    if err := json.Unmarshal(input, &in); err != nil {
        return "", fmt.Errorf("invalid input: %w", err)
    }

    switch in.Action {
    case "action1":
        // implementation
    case "action2":
        // implementation
    default:
        return "", fmt.Errorf("unknown action: %s", in.Action)
    }

    return "result string or JSON", nil
}
```

**Never** use complex structs â€” always return a simple string. Complex responses are JSON strings.

## Implementation Patterns

### Channels

Channels bridge external messaging platforms (Telegram, Discord, Slack).

Implement the `ChannelHandler` interface:
- `ID()` â€” returns channel identifier (e.g., "telegram", "discord")
- `Connect(ctx, settings)` â€” authenticate with the platform, start polling
- `Disconnect(ctx)` â€” cleanup
- `Send(ctx, envelope)` â€” send outbound message, return platform message ID
- `Receive(ctx)` â€” return a channel receiving inbound `ChannelEnvelope` objects

Inbound envelopes must have:
- `MessageID` (UUID v7 generated by your app)
- `ChannelID` (your platform_id, e.g., "telegram:12345")
- `Text` (message body)
- `Timestamp` (original platform timestamp, not bridge time)

Outbound `Send()` receives an envelope with text + optional `ReplyTo` (for threading). Return the platform's native message ID.

### Gateway

Gateways route LLM requests to models (like Janus).

Implement the `GatewayHandler` interface:
- `Stream(ctx, req)` â€” streaming RPC, send `GatewayEvent` objects as they arrive
- Each event has `Type` ("text", "tool_call", "thinking", "error", "done") and content

Your app makes HTTP requests to the upstream model API. As chunks arrive, unmarshal them and send `GatewayEvent` messages back.

### UI

UI apps provide configuration dashboards.

Implement the `UIHandler` interface:
- `Handler()` â€” return an `*http.ServeMux`

The SDK proxies HTTP requests from Nebo's browser to your mux. Write normal Go HTTP handlers â€” the SDK does the gRPC bridging.

Example:
```go
mux := http.NewServeMux()
mux.HandleFunc("GET /status", func(w http.ResponseWriter, r *http.Request) {
    json.NewEncoder(w).Encode(map[string]string{"status": "ok"})
})
```

When the user accesses the app's settings, their requests go to `POST /api/v1/apps/{id}/api/*`, which proxies to your handler.

### Schedule

Schedule apps replace Nebo's built-in cron.

Implement the `ScheduleHandler` interface:
- `Triggers(ctx)` â€” server-streaming RPC that yields `ScheduleTrigger` objects whenever a schedule fires
- `Create`, `Get`, `List`, `Update`, `Delete`, `Enable`, `Disable` â€” CRUD operations
- `History(ctx, name)` â€” execution history for the UI

Your app owns the schedule state. Nebo polls the `Triggers()` stream â€” keep it open and send a trigger whenever something fires.

## Workflow

### Step 1: Clarify the Requirement

Ask the user:
- What should this app do? (its purpose)
- What platform or API does it integrate with?
- What will the agent use it for?
- Does it need settings/configuration?

### Step 2: Scaffold the Project

**For gateway apps**, clone the boilerplate:
```bash
git clone https://github.com/NeboLoop/app-boilerplate.git my-new-app
cd my-new-app
```

**For tool, channel, UI, schedule, or comm apps**, generate from scratch:
1. Create a directory and `go mod init myapp`
2. `go get github.com/neboloop/nebo-sdk-go`
3. Write `manifest.json`, `SKILL.md`, and `main.go` (see patterns above)

### Step 3: Implement

1. **manifest.json** â€” set `id`, `name`, `provides`, `permissions`
2. **SKILL.md** â€” write agent instructions for your app's tools
3. **main.go** â€” implement the handler interface and register it with the SDK
4. **go.mod** â€” add any additional dependencies

### Step 4: Build Instructions

After code, provide:
- Build command (`go build -o binary .`)
- Installation path (`mkdir -p ~/Library/Application\ Support/Nebo/apps/com.example.appname && cp ...`)
- Verification steps (check socket exists, check logs)

### Step 5: Next Steps

Tell the user:
- Which permissions might need adding if it fails
- How to check logs for errors
- How to trigger a code reload (just rebuild + overwrite the binary)

## Marketplace Distribution

After building an app, it needs binaries for **all supported platforms** before it can be submitted to the NeboLoop marketplace.

### Supported Platforms

Nebo apps must be built for these 5 targets:

| Platform | GOOS | GOARCH | Binary Name | Notes |
|----------|------|--------|-------------|-------|
| macOS Apple Silicon | darwin | arm64 | `binary-darwin-arm64` | Primary dev platform |
| macOS Intel | darwin | amd64 | `binary-darwin-amd64` | |
| Linux x86_64 | linux | amd64 | `binary-linux-amd64` | |
| Linux ARM64 | linux | arm64 | `binary-linux-arm64` | |
| Windows x86_64 | windows | amd64 | `binary-windows-amd64.exe` | Must have `.exe` extension |

### Cross-Compilation

Nebo apps use gRPC over Unix sockets â€” they do NOT require CGO. Cross-compile with `CGO_ENABLED=0`:

```bash
# Build all platform binaries from any dev machine
CGO_ENABLED=0 GOOS=darwin GOARCH=arm64 go build -ldflags="-w -s" -o binary-darwin-arm64 .
CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build -ldflags="-w -s" -o binary-darwin-amd64 .
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags="-w -s" -o binary-linux-amd64 .
CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build -ldflags="-w -s" -o binary-linux-arm64 .
CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -ldflags="-w -s" -o binary-windows-amd64.exe .
```

### Uploading Binaries

Use the `app` tool to upload each platform binary directly from the local filesystem:

```
app(action: "upload_binary", id: "APP_ID", platform: "darwin-arm64", file_path: "dist/binary-darwin-arm64")
app(action: "upload_binary", id: "APP_ID", platform: "darwin-amd64", file_path: "dist/binary-darwin-amd64")
app(action: "upload_binary", id: "APP_ID", platform: "linux-amd64", file_path: "dist/binary-linux-amd64")
app(action: "upload_binary", id: "APP_ID", platform: "linux-arm64", file_path: "dist/binary-linux-arm64")
app(action: "upload_binary", id: "APP_ID", platform: "windows-amd64", file_path: "dist/binary-windows-amd64.exe")
```

The `APP_ID` is the UUID returned when the app was created in the marketplace. The app tool reads the local file and uploads it to NeboLoop â€” no tokens or curl needed.

### Complete Publish Workflow

```bash
# 1. Build all platform binaries
mkdir -p dist
for pair in "darwin arm64" "darwin amd64" "linux amd64" "linux arm64" "windows amd64"; do
  set -- $pair
  ext=""; [ "$1" = "windows" ] && ext=".exe"
  CGO_ENABLED=0 GOOS=$1 GOARCH=$2 go build -ldflags="-w -s" -o "dist/binary-$1-$2$ext" .
done
```

Then upload all 5 binaries using the store tool (see above).

## Anti-Patterns (NEVER DO THESE)

- Don't create multi-function APIs â€” use STRAP with `action` field
- Don't ask the user to fill in boilerplate â€” generate the whole thing
- Don't use `interface{}` or generic types â€” be specific with JSON schema
- Don't hardcode settings â€” read from environment or gRPC `Configure()`
- Don't forget error handling â€” every function should have a meaningful error
- Don't return `error` types to the agent â€” always return `string` from `Execute()`
- Don't skip the `SKILL.md` â€” it's required for distribution and guides the agent
- Don't declare more permissions than necessary â€” start minimal, add only when needed
- Don't forget the manifest version must be semver â€” "1.0.0", not "latest" or "1"
- Don't use goroutines in handlers unless absolutely necessary â€” keep handlers synchronous for simplicity

## Output Format

When generating an app, structure your response as:

```
## App: [Name]

[Brief description]

### manifest.json

[Full JSON]

### SKILL.md

[Full markdown]

### main.go

[Full Go code]

### Build & Install

[Clear step-by-step commands]

### Verification

[How to test the app works]

### Next Steps

[Common extensions or configuration options]
```

## Examples

For a calendar tool:
- Single `calendar` tool with actions: `get_events`, `create_event`, `check_availability`
- No `resource` field (single resource)
- Schema has `action` (required enum), then action-specific fields

For a project manager:
- Single `project` tool with `resource` (required enum: task, milestone) and `action`
- Supports both task and milestone operations
- STRAP pattern with `resource` routing

For a webhook/gateway:
- `gateway` capability (not `tool`)
- Streams `GatewayEvent` objects back to Nebo
- Requires `network:outbound` permission
- No tool â€” it's a model provider, not a task tool

## Performance Notes

- Start fast â€” apps have a 10-second startup window (configurable to 120s)
- Keep handlers synchronous â€” avoid heavy async operations in the hot path
- Use `context.Context` timeout to ensure streams don't hang
- Log to stderr â€” it's captured in `logs/stderr.log` for debugging

## Security Reminders

- No hardcoded secrets â€” read from `NEBO_APP_DATA` or environment variables set by Nebo at startup
- Don't trust `manifest.json` on disk â€” Nebo validates it before launch
- Binaries are immutable after signature (NeboLoop-distributed apps) â€” can't be modified at runtime
- Permissions are deny-by-default â€” if you don't declare `network:outbound`, you have no network access
- The sandbox restricts filesystem to `NEBO_APP_DATA` and temp â€” you can't write outside your app's directory

---

## Quick Reference: Handler Interfaces

| Capability | Interface | Key Methods |
|------------|-----------|-------------|
| `tool:*` | `ToolHandler` | `Name()`, `Description()`, `Schema()`, `Execute()` |
| `channel:*` | `ChannelHandler` | `ID()`, `Connect()`, `Disconnect()`, `Send()`, `Receive()` |
| `gateway` | `GatewayHandler` | `Stream()` |
| `ui` | `UIHandler` | `Handler()` |
| `schedule` | `ScheduleHandler` | `Triggers()`, `Create()`, `Get()`, `List()`, `Update()`, `Delete()`, `History()` |
| `comm` | `CommHandler` | `Send()`, `Subscribe()`, `Unsubscribe()`, `Receive()` |

The SDK (`nebo.New()`) handles gRPC setup, lifecycle, and signal handling. You implement the handler and call `app.RegisterTool()/RegisterChannel()/RegisterUI()/etc.` and `app.Run()`.
