package webview

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"sync"
	"time"
)

// CallbackResult is the payload POSTed by JS from the webview.
type CallbackResult struct {
	RequestID string          `json:"requestId"`
	Data      json.RawMessage `json:"data"`
	Error     string          `json:"error,omitempty"`
}

// CallbackCollector collects results from webview JS callbacks.
type CallbackCollector struct {
	mu       sync.Mutex
	pending  map[string]chan CallbackResult
}

var collector = &CallbackCollector{
	pending: make(map[string]chan CallbackResult),
}

// GetCollector returns the singleton callback collector.
func GetCollector() *CallbackCollector {
	return collector
}

// Register creates a pending request slot and returns its channel.
func (c *CallbackCollector) Register(requestID string) chan CallbackResult {
	c.mu.Lock()
	defer c.mu.Unlock()

	ch := make(chan CallbackResult, 1)
	c.pending[requestID] = ch
	return ch
}

// Deliver delivers a result for a pending request.
func (c *CallbackCollector) Deliver(result CallbackResult) {
	c.mu.Lock()
	ch, ok := c.pending[result.RequestID]
	if ok {
		delete(c.pending, result.RequestID)
	}
	c.mu.Unlock()

	if ok {
		ch <- result
	}
}

// Cleanup removes expired pending requests.
func (c *CallbackCollector) Cleanup(requestID string) {
	c.mu.Lock()
	defer c.mu.Unlock()
	delete(c.pending, requestID)
}

// WaitForResult blocks until a JS callback delivers the result, or timeout.
func WaitForResult(ctx context.Context, requestID string, timeout time.Duration) (json.RawMessage, error) {
	ch := collector.Register(requestID)
	defer collector.Cleanup(requestID)

	select {
	case result := <-ch:
		if result.Error != "" {
			return nil, fmt.Errorf("js error: %s", result.Error)
		}
		return result.Data, nil
	case <-time.After(timeout):
		return nil, fmt.Errorf("timeout waiting for webview response (request: %s)", requestID)
	case <-ctx.Done():
		return nil, ctx.Err()
	}
}

// CallbackHandler returns an http.HandlerFunc for POST /internal/webview/callback.
// This endpoint accepts requests from any origin because webview ExecJS callbacks
// originate from whatever external site is loaded in the native browser window.
// Security: localhost-only, requires a valid requestID generated by Go.
func CallbackHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// CORS: allow any origin â€” the webview loads external sites whose JS
		// must POST results back to this localhost endpoint.
		if origin := r.Header.Get("Origin"); origin != "" {
			w.Header().Set("Access-Control-Allow-Origin", origin)
			w.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS")
			w.Header().Set("Access-Control-Allow-Headers", "Content-Type")
		}

		if r.Method == http.MethodOptions {
			w.WriteHeader(http.StatusNoContent)
			return
		}

		if r.Method != http.MethodPost {
			http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
			return
		}

		var result CallbackResult
		if err := json.NewDecoder(r.Body).Decode(&result); err != nil {
			http.Error(w, "invalid json", http.StatusBadRequest)
			return
		}

		if result.RequestID == "" {
			http.Error(w, "missing requestId", http.StatusBadRequest)
			return
		}

		collector.Deliver(result)
		w.WriteHeader(http.StatusOK)
	}
}
