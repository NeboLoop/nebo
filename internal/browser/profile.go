package browser

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"
)

// IsProfileDecorated checks if a Chrome profile has been decorated with Nebo branding.
func IsProfileDecorated(userDataDir, desiredName, desiredColorHex string) bool {
	colorInt := parseHexToSignedARGB(desiredColorHex)

	localStatePath := filepath.Join(userDataDir, "Local State")
	prefsPath := filepath.Join(userDataDir, "Default", "Preferences")

	localState := safeReadJSON(localStatePath)
	prefs := safeReadJSON(prefsPath)

	// Check name in Local State
	infoCache := getNestedMap(localState, "profile", "info_cache", "Default")
	if infoCache != nil {
		if name, ok := infoCache["name"].(string); ok && name != desiredName {
			return false
		}
	}

	// Check color
	if colorInt != nil {
		// Check Local State color seed
		if infoCache != nil {
			if seed, ok := infoCache["profile_color_seed"].(float64); ok {
				if int32(seed) != *colorInt {
					return false
				}
			} else {
				return false
			}
		}

		// Check Preferences color
		browserTheme := getNestedMap(prefs, "browser", "theme")
		autogenTheme := getNestedMap(prefs, "autogenerated", "theme")

		colorOK := false
		if browserTheme != nil {
			if c, ok := browserTheme["user_color2"].(float64); ok && int32(c) == *colorInt {
				colorOK = true
			}
		}
		if autogenTheme != nil {
			if c, ok := autogenTheme["color"].(float64); ok && int32(c) == *colorInt {
				colorOK = true
			}
		}
		if !colorOK {
			return false
		}
	}

	return true
}

// DecorateProfile decorates a Chrome profile with Nebo branding (name + color).
func DecorateProfile(userDataDir, name, colorHex string) error {
	if name == "" {
		name = DefaultProfileName
	}
	colorHex = strings.ToUpper(strings.TrimPrefix(colorHex, "#"))
	if colorHex == "" {
		colorHex = strings.TrimPrefix(DefaultProfileColor, "#")
	}
	colorInt := parseHexToSignedARGB("#" + colorHex)

	localStatePath := filepath.Join(userDataDir, "Local State")
	prefsPath := filepath.Join(userDataDir, "Default", "Preferences")

	// Update Local State
	localState := safeReadJSON(localStatePath)
	if localState == nil {
		localState = make(map[string]any)
	}

	setNestedValue(localState, []string{"profile", "info_cache", "Default", "name"}, name)
	setNestedValue(localState, []string{"profile", "info_cache", "Default", "shortcut_name"}, name)
	setNestedValue(localState, []string{"profile", "info_cache", "Default", "user_name"}, name)
	setNestedValue(localState, []string{"profile", "info_cache", "Default", "profile_color"}, colorHex)
	setNestedValue(localState, []string{"profile", "info_cache", "Default", "user_color"}, colorHex)

	if colorInt != nil {
		setNestedValue(localState, []string{"profile", "info_cache", "Default", "profile_color_seed"}, *colorInt)
		setNestedValue(localState, []string{"profile", "info_cache", "Default", "profile_highlight_color"}, *colorInt)
		setNestedValue(localState, []string{"profile", "info_cache", "Default", "default_avatar_fill_color"}, *colorInt)
		setNestedValue(localState, []string{"profile", "info_cache", "Default", "default_avatar_stroke_color"}, *colorInt)
	}

	if err := safeWriteJSON(localStatePath, localState); err != nil {
		return fmt.Errorf("failed to write Local State: %w", err)
	}

	// Update Preferences
	prefs := safeReadJSON(prefsPath)
	if prefs == nil {
		prefs = make(map[string]any)
	}

	setNestedValue(prefs, []string{"profile", "name"}, name)
	setNestedValue(prefs, []string{"profile", "profile_color"}, colorHex)
	setNestedValue(prefs, []string{"profile", "user_color"}, colorHex)

	if colorInt != nil {
		setNestedValue(prefs, []string{"autogenerated", "theme", "color"}, *colorInt)
		setNestedValue(prefs, []string{"browser", "theme", "user_color2"}, *colorInt)
	}

	if err := safeWriteJSON(prefsPath, prefs); err != nil {
		return fmt.Errorf("failed to write Preferences: %w", err)
	}

	// Write decoration marker
	markerPath := filepath.Join(userDataDir, ".nebo-profile-decorated")
	_ = os.WriteFile(markerPath, []byte(fmt.Sprintf("%d\n", time.Now().Unix())), 0644)

	return nil
}

// EnsureCleanExit sets Chrome preferences to avoid "restore pages" dialogs.
func EnsureCleanExit(userDataDir string) {
	prefsPath := filepath.Join(userDataDir, "Default", "Preferences")
	prefs := safeReadJSON(prefsPath)
	if prefs == nil {
		prefs = make(map[string]any)
	}

	setNestedValue(prefs, []string{"exit_type"}, "Normal")
	setNestedValue(prefs, []string{"exited_cleanly"}, true)

	_ = safeWriteJSON(prefsPath, prefs)

	// Remove stale lock files that prevent Chrome from starting.
	// Chrome uses these files to prevent multiple instances from accessing the same user-data-dir.
	// If Chrome crashed, these files can persist and cause "allocator multiple times" errors.
	lockFiles := []string{
		filepath.Join(userDataDir, "SingletonLock"),
		filepath.Join(userDataDir, "SingletonSocket"),
		filepath.Join(userDataDir, "SingletonCookie"),
	}
	for _, lockFile := range lockFiles {
		_ = os.Remove(lockFile)
	}
}

// parseHexToSignedARGB converts a hex color to Chrome's signed 32-bit ARGB int.
// Chrome stores colors as signed 32-bit ints (SkColor).
func parseHexToSignedARGB(hex string) *int32 {
	hex = strings.TrimPrefix(strings.TrimSpace(hex), "#")
	if len(hex) != 6 {
		return nil
	}

	rgb, err := strconv.ParseUint(hex, 16, 32)
	if err != nil {
		return nil
	}

	// Add full alpha (0xFF) and convert to signed int32
	argbUnsigned := uint32(0xFF<<24) | uint32(rgb)

	// Convert to signed (Chrome uses signed ints)
	// Use int64 for the subtraction to avoid overflow
	var result int32
	if argbUnsigned > 0x7FFFFFFF {
		result = int32(int64(argbUnsigned) - 0x100000000)
	} else {
		result = int32(argbUnsigned)
	}

	return &result
}

func safeReadJSON(path string) map[string]any {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil
	}

	var result map[string]any
	if err := json.Unmarshal(data, &result); err != nil {
		return nil
	}

	return result
}

func safeWriteJSON(path string, data map[string]any) error {
	if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {
		return err
	}

	content, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		return err
	}

	return os.WriteFile(path, content, 0644)
}

func getNestedMap(m map[string]any, keys ...string) map[string]any {
	current := m
	for _, key := range keys {
		if current == nil {
			return nil
		}
		next, ok := current[key].(map[string]any)
		if !ok {
			return nil
		}
		current = next
	}
	return current
}

func setNestedValue(m map[string]any, keys []string, value any) {
	if len(keys) == 0 {
		return
	}

	current := m
	for _, key := range keys[:len(keys)-1] {
		next, ok := current[key].(map[string]any)
		if !ok {
			next = make(map[string]any)
			current[key] = next
		}
		current = next
	}

	current[keys[len(keys)-1]] = value
}
