// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: memories.sql

package db

import (
	"context"
	"database/sql"
)

const countMemories = `-- name: CountMemories :one
SELECT COUNT(*) as total FROM memories
`

func (q *Queries) CountMemories(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMemories)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countMemoriesByNamespace = `-- name: CountMemoriesByNamespace :one
SELECT COUNT(*) as total FROM memories
WHERE namespace LIKE ?1 || '%'
`

func (q *Queries) CountMemoriesByNamespace(ctx context.Context, namespacePrefix sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMemoriesByNamespace, namespacePrefix)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const deleteMemoriesByNamespaceAndUser = `-- name: DeleteMemoriesByNamespaceAndUser :execresult
DELETE FROM memories
WHERE namespace LIKE ?1 || '%' AND user_id = ?2
`

type DeleteMemoriesByNamespaceAndUserParams struct {
	NamespacePrefix sql.NullString `json:"namespace_prefix"`
	UserID          string         `json:"user_id"`
}

func (q *Queries) DeleteMemoriesByNamespaceAndUser(ctx context.Context, arg DeleteMemoriesByNamespaceAndUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteMemoriesByNamespaceAndUser, arg.NamespacePrefix, arg.UserID)
}

const deleteMemory = `-- name: DeleteMemory :exec
DELETE FROM memories WHERE id = ?
`

func (q *Queries) DeleteMemory(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMemory, id)
	return err
}

const deleteMemoryByKeyAndUser = `-- name: DeleteMemoryByKeyAndUser :execresult
DELETE FROM memories
WHERE namespace = ? AND key = ? AND user_id = ?
`

type DeleteMemoryByKeyAndUserParams struct {
	Namespace string `json:"namespace"`
	Key       string `json:"key"`
	UserID    string `json:"user_id"`
}

func (q *Queries) DeleteMemoryByKeyAndUser(ctx context.Context, arg DeleteMemoryByKeyAndUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteMemoryByKeyAndUser, arg.Namespace, arg.Key, arg.UserID)
}

const deleteMemoryByKeyAndUserAnyNamespace = `-- name: DeleteMemoryByKeyAndUserAnyNamespace :execresult
DELETE FROM memories
WHERE key = ? AND user_id = ?
`

type DeleteMemoryByKeyAndUserAnyNamespaceParams struct {
	Key    string `json:"key"`
	UserID string `json:"user_id"`
}

func (q *Queries) DeleteMemoryByKeyAndUserAnyNamespace(ctx context.Context, arg DeleteMemoryByKeyAndUserAnyNamespaceParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteMemoryByKeyAndUserAnyNamespace, arg.Key, arg.UserID)
}

const getDistinctNamespaces = `-- name: GetDistinctNamespaces :many
SELECT DISTINCT namespace FROM memories ORDER BY namespace
`

func (q *Queries) GetDistinctNamespaces(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getDistinctNamespaces)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var namespace string
		if err := rows.Scan(&namespace); err != nil {
			return nil, err
		}
		items = append(items, namespace)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMemory = `-- name: GetMemory :one
SELECT id, namespace, key, value, tags, metadata, created_at, updated_at, accessed_at, access_count
FROM memories
WHERE id = ?
`

type GetMemoryRow struct {
	ID          int64          `json:"id"`
	Namespace   string         `json:"namespace"`
	Key         string         `json:"key"`
	Value       string         `json:"value"`
	Tags        sql.NullString `json:"tags"`
	Metadata    sql.NullString `json:"metadata"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
	AccessedAt  sql.NullTime   `json:"accessed_at"`
	AccessCount sql.NullInt64  `json:"access_count"`
}

func (q *Queries) GetMemory(ctx context.Context, id int64) (GetMemoryRow, error) {
	row := q.db.QueryRowContext(ctx, getMemory, id)
	var i GetMemoryRow
	err := row.Scan(
		&i.ID,
		&i.Namespace,
		&i.Key,
		&i.Value,
		&i.Tags,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessedAt,
		&i.AccessCount,
	)
	return i, err
}

const getMemoryByKey = `-- name: GetMemoryByKey :one
SELECT id, namespace, key, value, tags, metadata, created_at, updated_at, accessed_at, access_count
FROM memories
WHERE namespace = ? AND key = ?
`

type GetMemoryByKeyParams struct {
	Namespace string `json:"namespace"`
	Key       string `json:"key"`
}

type GetMemoryByKeyRow struct {
	ID          int64          `json:"id"`
	Namespace   string         `json:"namespace"`
	Key         string         `json:"key"`
	Value       string         `json:"value"`
	Tags        sql.NullString `json:"tags"`
	Metadata    sql.NullString `json:"metadata"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
	AccessedAt  sql.NullTime   `json:"accessed_at"`
	AccessCount sql.NullInt64  `json:"access_count"`
}

func (q *Queries) GetMemoryByKey(ctx context.Context, arg GetMemoryByKeyParams) (GetMemoryByKeyRow, error) {
	row := q.db.QueryRowContext(ctx, getMemoryByKey, arg.Namespace, arg.Key)
	var i GetMemoryByKeyRow
	err := row.Scan(
		&i.ID,
		&i.Namespace,
		&i.Key,
		&i.Value,
		&i.Tags,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessedAt,
		&i.AccessCount,
	)
	return i, err
}

const getMemoryByKeyAndUser = `-- name: GetMemoryByKeyAndUser :one
SELECT id, namespace, key, value, tags, metadata, created_at, updated_at, accessed_at, access_count
FROM memories
WHERE namespace = ? AND key = ? AND user_id = ?
`

type GetMemoryByKeyAndUserParams struct {
	Namespace string `json:"namespace"`
	Key       string `json:"key"`
	UserID    string `json:"user_id"`
}

type GetMemoryByKeyAndUserRow struct {
	ID          int64          `json:"id"`
	Namespace   string         `json:"namespace"`
	Key         string         `json:"key"`
	Value       string         `json:"value"`
	Tags        sql.NullString `json:"tags"`
	Metadata    sql.NullString `json:"metadata"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
	AccessedAt  sql.NullTime   `json:"accessed_at"`
	AccessCount sql.NullInt64  `json:"access_count"`
}

func (q *Queries) GetMemoryByKeyAndUser(ctx context.Context, arg GetMemoryByKeyAndUserParams) (GetMemoryByKeyAndUserRow, error) {
	row := q.db.QueryRowContext(ctx, getMemoryByKeyAndUser, arg.Namespace, arg.Key, arg.UserID)
	var i GetMemoryByKeyAndUserRow
	err := row.Scan(
		&i.ID,
		&i.Namespace,
		&i.Key,
		&i.Value,
		&i.Tags,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessedAt,
		&i.AccessCount,
	)
	return i, err
}

const getMemoryByKeyAndUserAnyNamespace = `-- name: GetMemoryByKeyAndUserAnyNamespace :one
SELECT id, namespace, key, value, tags, metadata, created_at, updated_at, accessed_at, access_count
FROM memories
WHERE key = ? AND user_id = ?
ORDER BY access_count DESC
LIMIT 1
`

type GetMemoryByKeyAndUserAnyNamespaceParams struct {
	Key    string `json:"key"`
	UserID string `json:"user_id"`
}

type GetMemoryByKeyAndUserAnyNamespaceRow struct {
	ID          int64          `json:"id"`
	Namespace   string         `json:"namespace"`
	Key         string         `json:"key"`
	Value       string         `json:"value"`
	Tags        sql.NullString `json:"tags"`
	Metadata    sql.NullString `json:"metadata"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
	AccessedAt  sql.NullTime   `json:"accessed_at"`
	AccessCount sql.NullInt64  `json:"access_count"`
}

func (q *Queries) GetMemoryByKeyAndUserAnyNamespace(ctx context.Context, arg GetMemoryByKeyAndUserAnyNamespaceParams) (GetMemoryByKeyAndUserAnyNamespaceRow, error) {
	row := q.db.QueryRowContext(ctx, getMemoryByKeyAndUserAnyNamespace, arg.Key, arg.UserID)
	var i GetMemoryByKeyAndUserAnyNamespaceRow
	err := row.Scan(
		&i.ID,
		&i.Namespace,
		&i.Key,
		&i.Value,
		&i.Tags,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessedAt,
		&i.AccessCount,
	)
	return i, err
}

const getMemoryStats = `-- name: GetMemoryStats :many
SELECT
    CASE
        WHEN namespace LIKE 'tacit/%' THEN 'tacit'
        WHEN namespace LIKE 'daily/%' THEN 'daily'
        WHEN namespace LIKE 'entity/%' THEN 'entity'
        ELSE 'other'
    END as layer,
    COUNT(*) as count
FROM memories
GROUP BY 1
ORDER BY 1
`

type GetMemoryStatsRow struct {
	Layer string `json:"layer"`
	Count int64  `json:"count"`
}

func (q *Queries) GetMemoryStats(ctx context.Context) ([]GetMemoryStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMemoryStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMemoryStatsRow
	for rows.Next() {
		var i GetMemoryStatsRow
		if err := rows.Scan(&i.Layer, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTacitMemoriesByUser = `-- name: GetTacitMemoriesByUser :many
SELECT id, namespace, key, value, tags, metadata, created_at, updated_at, accessed_at, access_count
FROM memories
WHERE namespace LIKE 'tacit/%' AND user_id = ?
ORDER BY access_count DESC
LIMIT ?2
`

type GetTacitMemoriesByUserParams struct {
	UserID string `json:"user_id"`
	Limit  int64  `json:"limit"`
}

type GetTacitMemoriesByUserRow struct {
	ID          int64          `json:"id"`
	Namespace   string         `json:"namespace"`
	Key         string         `json:"key"`
	Value       string         `json:"value"`
	Tags        sql.NullString `json:"tags"`
	Metadata    sql.NullString `json:"metadata"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
	AccessedAt  sql.NullTime   `json:"accessed_at"`
	AccessCount sql.NullInt64  `json:"access_count"`
}

func (q *Queries) GetTacitMemoriesByUser(ctx context.Context, arg GetTacitMemoriesByUserParams) ([]GetTacitMemoriesByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getTacitMemoriesByUser, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTacitMemoriesByUserRow
	for rows.Next() {
		var i GetTacitMemoriesByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Namespace,
			&i.Key,
			&i.Value,
			&i.Tags,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccessedAt,
			&i.AccessCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementMemoryAccess = `-- name: IncrementMemoryAccess :exec
UPDATE memories
SET access_count = access_count + 1,
    accessed_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) IncrementMemoryAccess(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, incrementMemoryAccess, id)
	return err
}

const incrementMemoryAccessByKey = `-- name: IncrementMemoryAccessByKey :exec
UPDATE memories
SET access_count = access_count + 1,
    accessed_at = CURRENT_TIMESTAMP
WHERE namespace = ? AND key = ? AND user_id = ?
`

type IncrementMemoryAccessByKeyParams struct {
	Namespace string `json:"namespace"`
	Key       string `json:"key"`
	UserID    string `json:"user_id"`
}

func (q *Queries) IncrementMemoryAccessByKey(ctx context.Context, arg IncrementMemoryAccessByKeyParams) error {
	_, err := q.db.ExecContext(ctx, incrementMemoryAccessByKey, arg.Namespace, arg.Key, arg.UserID)
	return err
}

const listMemories = `-- name: ListMemories :many

SELECT id, namespace, key, value, tags, metadata, created_at, updated_at, accessed_at, access_count
FROM memories
ORDER BY
    CASE WHEN namespace LIKE 'tacit/%' THEN 0
         WHEN namespace LIKE 'entity/%' THEN 1
         ELSE 2 END,
    access_count DESC
LIMIT ?2 OFFSET ?1
`

type ListMemoriesParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

type ListMemoriesRow struct {
	ID          int64          `json:"id"`
	Namespace   string         `json:"namespace"`
	Key         string         `json:"key"`
	Value       string         `json:"value"`
	Tags        sql.NullString `json:"tags"`
	Metadata    sql.NullString `json:"metadata"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
	AccessedAt  sql.NullTime   `json:"accessed_at"`
	AccessCount sql.NullInt64  `json:"access_count"`
}

// Memory queries
func (q *Queries) ListMemories(ctx context.Context, arg ListMemoriesParams) ([]ListMemoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, listMemories, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMemoriesRow
	for rows.Next() {
		var i ListMemoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.Namespace,
			&i.Key,
			&i.Value,
			&i.Tags,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccessedAt,
			&i.AccessCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMemoriesByNamespace = `-- name: ListMemoriesByNamespace :many
SELECT id, namespace, key, value, tags, metadata, created_at, updated_at, accessed_at, access_count
FROM memories
WHERE namespace LIKE ?1 || '%'
ORDER BY access_count DESC
LIMIT ?3 OFFSET ?2
`

type ListMemoriesByNamespaceParams struct {
	NamespacePrefix sql.NullString `json:"namespace_prefix"`
	Offset          int64          `json:"offset"`
	Limit           int64          `json:"limit"`
}

type ListMemoriesByNamespaceRow struct {
	ID          int64          `json:"id"`
	Namespace   string         `json:"namespace"`
	Key         string         `json:"key"`
	Value       string         `json:"value"`
	Tags        sql.NullString `json:"tags"`
	Metadata    sql.NullString `json:"metadata"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
	AccessedAt  sql.NullTime   `json:"accessed_at"`
	AccessCount sql.NullInt64  `json:"access_count"`
}

func (q *Queries) ListMemoriesByNamespace(ctx context.Context, arg ListMemoriesByNamespaceParams) ([]ListMemoriesByNamespaceRow, error) {
	rows, err := q.db.QueryContext(ctx, listMemoriesByNamespace, arg.NamespacePrefix, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMemoriesByNamespaceRow
	for rows.Next() {
		var i ListMemoriesByNamespaceRow
		if err := rows.Scan(
			&i.ID,
			&i.Namespace,
			&i.Key,
			&i.Value,
			&i.Tags,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccessedAt,
			&i.AccessCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMemoriesByUserAndNamespace = `-- name: ListMemoriesByUserAndNamespace :many
SELECT id, namespace, key, value, tags, metadata, created_at, updated_at, accessed_at, access_count
FROM memories
WHERE user_id = ?1 AND namespace LIKE ?2 || '%'
ORDER BY access_count DESC
LIMIT ?4 OFFSET ?3
`

type ListMemoriesByUserAndNamespaceParams struct {
	UserID          string         `json:"user_id"`
	NamespacePrefix sql.NullString `json:"namespace_prefix"`
	Offset          int64          `json:"offset"`
	Limit           int64          `json:"limit"`
}

type ListMemoriesByUserAndNamespaceRow struct {
	ID          int64          `json:"id"`
	Namespace   string         `json:"namespace"`
	Key         string         `json:"key"`
	Value       string         `json:"value"`
	Tags        sql.NullString `json:"tags"`
	Metadata    sql.NullString `json:"metadata"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
	AccessedAt  sql.NullTime   `json:"accessed_at"`
	AccessCount sql.NullInt64  `json:"access_count"`
}

func (q *Queries) ListMemoriesByUserAndNamespace(ctx context.Context, arg ListMemoriesByUserAndNamespaceParams) ([]ListMemoriesByUserAndNamespaceRow, error) {
	rows, err := q.db.QueryContext(ctx, listMemoriesByUserAndNamespace,
		arg.UserID,
		arg.NamespacePrefix,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMemoriesByUserAndNamespaceRow
	for rows.Next() {
		var i ListMemoriesByUserAndNamespaceRow
		if err := rows.Scan(
			&i.ID,
			&i.Namespace,
			&i.Key,
			&i.Value,
			&i.Tags,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccessedAt,
			&i.AccessCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMemories = `-- name: SearchMemories :many
SELECT id, namespace, key, value, tags, metadata, created_at, updated_at, accessed_at, access_count
FROM memories
WHERE key LIKE '%' || ?1 || '%'
   OR value LIKE '%' || ?1 || '%'
   OR tags LIKE '%' || ?1 || '%'
ORDER BY access_count DESC
LIMIT ?3 OFFSET ?2
`

type SearchMemoriesParams struct {
	Query  sql.NullString `json:"query"`
	Offset int64          `json:"offset"`
	Limit  int64          `json:"limit"`
}

type SearchMemoriesRow struct {
	ID          int64          `json:"id"`
	Namespace   string         `json:"namespace"`
	Key         string         `json:"key"`
	Value       string         `json:"value"`
	Tags        sql.NullString `json:"tags"`
	Metadata    sql.NullString `json:"metadata"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
	AccessedAt  sql.NullTime   `json:"accessed_at"`
	AccessCount sql.NullInt64  `json:"access_count"`
}

func (q *Queries) SearchMemories(ctx context.Context, arg SearchMemoriesParams) ([]SearchMemoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, searchMemories, arg.Query, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchMemoriesRow
	for rows.Next() {
		var i SearchMemoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.Namespace,
			&i.Key,
			&i.Value,
			&i.Tags,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccessedAt,
			&i.AccessCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMemoriesByUser = `-- name: SearchMemoriesByUser :many
SELECT id, namespace, key, value, tags, metadata, created_at, updated_at, accessed_at, access_count
FROM memories
WHERE user_id = ?1
  AND (namespace LIKE '%' || ?2 || '%'
       OR key LIKE '%' || ?2 || '%'
       OR value LIKE '%' || ?2 || '%')
ORDER BY access_count DESC
LIMIT ?4 OFFSET ?3
`

type SearchMemoriesByUserParams struct {
	UserID string         `json:"user_id"`
	Query  sql.NullString `json:"query"`
	Offset int64          `json:"offset"`
	Limit  int64          `json:"limit"`
}

type SearchMemoriesByUserRow struct {
	ID          int64          `json:"id"`
	Namespace   string         `json:"namespace"`
	Key         string         `json:"key"`
	Value       string         `json:"value"`
	Tags        sql.NullString `json:"tags"`
	Metadata    sql.NullString `json:"metadata"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
	AccessedAt  sql.NullTime   `json:"accessed_at"`
	AccessCount sql.NullInt64  `json:"access_count"`
}

func (q *Queries) SearchMemoriesByUser(ctx context.Context, arg SearchMemoriesByUserParams) ([]SearchMemoriesByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, searchMemoriesByUser,
		arg.UserID,
		arg.Query,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchMemoriesByUserRow
	for rows.Next() {
		var i SearchMemoriesByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Namespace,
			&i.Key,
			&i.Value,
			&i.Tags,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccessedAt,
			&i.AccessCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMemoriesByUserAndNamespace = `-- name: SearchMemoriesByUserAndNamespace :many
SELECT id, namespace, key, value, tags, metadata, created_at, updated_at, accessed_at, access_count
FROM memories
WHERE user_id = ?1 AND namespace LIKE ?2 || '%'
  AND (key LIKE '%' || ?3 || '%'
       OR value LIKE '%' || ?3 || '%')
ORDER BY access_count DESC
LIMIT ?5 OFFSET ?4
`

type SearchMemoriesByUserAndNamespaceParams struct {
	UserID          string         `json:"user_id"`
	NamespacePrefix sql.NullString `json:"namespace_prefix"`
	Query           sql.NullString `json:"query"`
	Offset          int64          `json:"offset"`
	Limit           int64          `json:"limit"`
}

type SearchMemoriesByUserAndNamespaceRow struct {
	ID          int64          `json:"id"`
	Namespace   string         `json:"namespace"`
	Key         string         `json:"key"`
	Value       string         `json:"value"`
	Tags        sql.NullString `json:"tags"`
	Metadata    sql.NullString `json:"metadata"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
	AccessedAt  sql.NullTime   `json:"accessed_at"`
	AccessCount sql.NullInt64  `json:"access_count"`
}

func (q *Queries) SearchMemoriesByUserAndNamespace(ctx context.Context, arg SearchMemoriesByUserAndNamespaceParams) ([]SearchMemoriesByUserAndNamespaceRow, error) {
	rows, err := q.db.QueryContext(ctx, searchMemoriesByUserAndNamespace,
		arg.UserID,
		arg.NamespacePrefix,
		arg.Query,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchMemoriesByUserAndNamespaceRow
	for rows.Next() {
		var i SearchMemoriesByUserAndNamespaceRow
		if err := rows.Scan(
			&i.ID,
			&i.Namespace,
			&i.Key,
			&i.Value,
			&i.Tags,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccessedAt,
			&i.AccessCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMemory = `-- name: UpdateMemory :exec
UPDATE memories
SET value = COALESCE(?1, value),
    tags = COALESCE(?2, tags),
    metadata = COALESCE(?3, metadata),
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?4
`

type UpdateMemoryParams struct {
	Value    sql.NullString `json:"value"`
	Tags     sql.NullString `json:"tags"`
	Metadata sql.NullString `json:"metadata"`
	ID       int64          `json:"id"`
}

func (q *Queries) UpdateMemory(ctx context.Context, arg UpdateMemoryParams) error {
	_, err := q.db.ExecContext(ctx, updateMemory,
		arg.Value,
		arg.Tags,
		arg.Metadata,
		arg.ID,
	)
	return err
}

const upsertMemory = `-- name: UpsertMemory :exec

INSERT INTO memories (namespace, key, value, tags, metadata, user_id, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
ON CONFLICT(namespace, key, user_id) DO UPDATE SET
    value = excluded.value,
    tags = excluded.tags,
    metadata = excluded.metadata,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertMemoryParams struct {
	Namespace string         `json:"namespace"`
	Key       string         `json:"key"`
	Value     string         `json:"value"`
	Tags      sql.NullString `json:"tags"`
	Metadata  sql.NullString `json:"metadata"`
	UserID    string         `json:"user_id"`
}

// User-scoped memory queries for agent tools
func (q *Queries) UpsertMemory(ctx context.Context, arg UpsertMemoryParams) error {
	_, err := q.db.ExecContext(ctx, upsertMemory,
		arg.Namespace,
		arg.Key,
		arg.Value,
		arg.Tags,
		arg.Metadata,
		arg.UserID,
	)
	return err
}
