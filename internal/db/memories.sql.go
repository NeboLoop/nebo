// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: memories.sql

package db

import (
	"context"
	"database/sql"
)

const countMemories = `-- name: CountMemories :one
SELECT COUNT(*) as total FROM memories
`

func (q *Queries) CountMemories(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMemories)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countMemoriesByNamespace = `-- name: CountMemoriesByNamespace :one
SELECT COUNT(*) as total FROM memories
WHERE namespace LIKE ?1 || '%'
`

func (q *Queries) CountMemoriesByNamespace(ctx context.Context, namespacePrefix sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMemoriesByNamespace, namespacePrefix)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const deleteMemory = `-- name: DeleteMemory :exec
DELETE FROM memories WHERE id = ?
`

func (q *Queries) DeleteMemory(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMemory, id)
	return err
}

const getDistinctNamespaces = `-- name: GetDistinctNamespaces :many
SELECT DISTINCT namespace FROM memories ORDER BY namespace
`

func (q *Queries) GetDistinctNamespaces(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getDistinctNamespaces)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var namespace string
		if err := rows.Scan(&namespace); err != nil {
			return nil, err
		}
		items = append(items, namespace)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMemory = `-- name: GetMemory :one
SELECT id, namespace, key, value, tags, metadata, created_at, updated_at, accessed_at, access_count
FROM memories
WHERE id = ?
`

func (q *Queries) GetMemory(ctx context.Context, id int64) (Memory, error) {
	row := q.db.QueryRowContext(ctx, getMemory, id)
	var i Memory
	err := row.Scan(
		&i.ID,
		&i.Namespace,
		&i.Key,
		&i.Value,
		&i.Tags,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessedAt,
		&i.AccessCount,
	)
	return i, err
}

const getMemoryByKey = `-- name: GetMemoryByKey :one
SELECT id, namespace, key, value, tags, metadata, created_at, updated_at, accessed_at, access_count
FROM memories
WHERE namespace = ? AND key = ?
`

type GetMemoryByKeyParams struct {
	Namespace string `json:"namespace"`
	Key       string `json:"key"`
}

func (q *Queries) GetMemoryByKey(ctx context.Context, arg GetMemoryByKeyParams) (Memory, error) {
	row := q.db.QueryRowContext(ctx, getMemoryByKey, arg.Namespace, arg.Key)
	var i Memory
	err := row.Scan(
		&i.ID,
		&i.Namespace,
		&i.Key,
		&i.Value,
		&i.Tags,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessedAt,
		&i.AccessCount,
	)
	return i, err
}

const getMemoryStats = `-- name: GetMemoryStats :many
SELECT
    CASE
        WHEN namespace LIKE 'tacit.%' THEN 'tacit'
        WHEN namespace LIKE 'daily.%' THEN 'daily'
        WHEN namespace LIKE 'entity.%' THEN 'entity'
        ELSE 'other'
    END as layer,
    COUNT(*) as count
FROM memories
GROUP BY 1
ORDER BY 1
`

type GetMemoryStatsRow struct {
	Layer string `json:"layer"`
	Count int64  `json:"count"`
}

func (q *Queries) GetMemoryStats(ctx context.Context) ([]GetMemoryStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMemoryStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMemoryStatsRow
	for rows.Next() {
		var i GetMemoryStatsRow
		if err := rows.Scan(&i.Layer, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementMemoryAccess = `-- name: IncrementMemoryAccess :exec
UPDATE memories
SET access_count = access_count + 1,
    accessed_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) IncrementMemoryAccess(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, incrementMemoryAccess, id)
	return err
}

const listMemories = `-- name: ListMemories :many

SELECT id, namespace, key, value, tags, metadata, created_at, updated_at, accessed_at, access_count
FROM memories
ORDER BY
    CASE WHEN namespace LIKE 'tacit.%' THEN 0
         WHEN namespace LIKE 'entity.%' THEN 1
         ELSE 2 END,
    access_count DESC
LIMIT ?2 OFFSET ?1
`

type ListMemoriesParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

// Memory queries
func (q *Queries) ListMemories(ctx context.Context, arg ListMemoriesParams) ([]Memory, error) {
	rows, err := q.db.QueryContext(ctx, listMemories, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Memory
	for rows.Next() {
		var i Memory
		if err := rows.Scan(
			&i.ID,
			&i.Namespace,
			&i.Key,
			&i.Value,
			&i.Tags,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccessedAt,
			&i.AccessCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMemoriesByNamespace = `-- name: ListMemoriesByNamespace :many
SELECT id, namespace, key, value, tags, metadata, created_at, updated_at, accessed_at, access_count
FROM memories
WHERE namespace LIKE ?1 || '%'
ORDER BY access_count DESC
LIMIT ?3 OFFSET ?2
`

type ListMemoriesByNamespaceParams struct {
	NamespacePrefix sql.NullString `json:"namespace_prefix"`
	Offset          int64          `json:"offset"`
	Limit           int64          `json:"limit"`
}

func (q *Queries) ListMemoriesByNamespace(ctx context.Context, arg ListMemoriesByNamespaceParams) ([]Memory, error) {
	rows, err := q.db.QueryContext(ctx, listMemoriesByNamespace, arg.NamespacePrefix, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Memory
	for rows.Next() {
		var i Memory
		if err := rows.Scan(
			&i.ID,
			&i.Namespace,
			&i.Key,
			&i.Value,
			&i.Tags,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccessedAt,
			&i.AccessCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMemories = `-- name: SearchMemories :many
SELECT id, namespace, key, value, tags, metadata, created_at, updated_at, accessed_at, access_count
FROM memories
WHERE key LIKE '%' || ?1 || '%'
   OR value LIKE '%' || ?1 || '%'
   OR tags LIKE '%' || ?1 || '%'
ORDER BY access_count DESC
LIMIT ?3 OFFSET ?2
`

type SearchMemoriesParams struct {
	Query  sql.NullString `json:"query"`
	Offset int64          `json:"offset"`
	Limit  int64          `json:"limit"`
}

func (q *Queries) SearchMemories(ctx context.Context, arg SearchMemoriesParams) ([]Memory, error) {
	rows, err := q.db.QueryContext(ctx, searchMemories, arg.Query, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Memory
	for rows.Next() {
		var i Memory
		if err := rows.Scan(
			&i.ID,
			&i.Namespace,
			&i.Key,
			&i.Value,
			&i.Tags,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccessedAt,
			&i.AccessCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMemory = `-- name: UpdateMemory :exec
UPDATE memories
SET value = COALESCE(?1, value),
    tags = COALESCE(?2, tags),
    metadata = COALESCE(?3, metadata),
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?4
`

type UpdateMemoryParams struct {
	Value    sql.NullString `json:"value"`
	Tags     sql.NullString `json:"tags"`
	Metadata sql.NullString `json:"metadata"`
	ID       int64          `json:"id"`
}

func (q *Queries) UpdateMemory(ctx context.Context, arg UpdateMemoryParams) error {
	_, err := q.db.ExecContext(ctx, updateMemory,
		arg.Value,
		arg.Tags,
		arg.Metadata,
		arg.ID,
	)
	return err
}
