// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: embeddings.sql

package db

import (
	"context"
	"database/sql"
)

const cleanOldEmbeddingCache = `-- name: CleanOldEmbeddingCache :exec
DELETE FROM embedding_cache WHERE created_at < ?
`

func (q *Queries) CleanOldEmbeddingCache(ctx context.Context, createdAt sql.NullTime) error {
	_, err := q.db.ExecContext(ctx, cleanOldEmbeddingCache, createdAt)
	return err
}

const countMemoryEmbeddings = `-- name: CountMemoryEmbeddings :one
SELECT COUNT(*) as total FROM memory_embeddings WHERE model = ?
`

func (q *Queries) CountMemoryEmbeddings(ctx context.Context, model string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMemoryEmbeddings, model)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createMemoryChunk = `-- name: CreateMemoryChunk :one

INSERT INTO memory_chunks (memory_id, chunk_index, text, source, path, start_line, end_line, model)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, memory_id, chunk_index, text, source, path, start_line, end_line, model, created_at
`

type CreateMemoryChunkParams struct {
	MemoryID   sql.NullInt64  `json:"memory_id"`
	ChunkIndex int64          `json:"chunk_index"`
	Text       string         `json:"text"`
	Source     sql.NullString `json:"source"`
	Path       sql.NullString `json:"path"`
	StartLine  sql.NullInt64  `json:"start_line"`
	EndLine    sql.NullInt64  `json:"end_line"`
	Model      sql.NullString `json:"model"`
}

type CreateMemoryChunkRow struct {
	ID         int64          `json:"id"`
	MemoryID   sql.NullInt64  `json:"memory_id"`
	ChunkIndex int64          `json:"chunk_index"`
	Text       string         `json:"text"`
	Source     sql.NullString `json:"source"`
	Path       sql.NullString `json:"path"`
	StartLine  sql.NullInt64  `json:"start_line"`
	EndLine    sql.NullInt64  `json:"end_line"`
	Model      sql.NullString `json:"model"`
	CreatedAt  sql.NullTime   `json:"created_at"`
}

// Memory chunks queries
func (q *Queries) CreateMemoryChunk(ctx context.Context, arg CreateMemoryChunkParams) (CreateMemoryChunkRow, error) {
	row := q.db.QueryRowContext(ctx, createMemoryChunk,
		arg.MemoryID,
		arg.ChunkIndex,
		arg.Text,
		arg.Source,
		arg.Path,
		arg.StartLine,
		arg.EndLine,
		arg.Model,
	)
	var i CreateMemoryChunkRow
	err := row.Scan(
		&i.ID,
		&i.MemoryID,
		&i.ChunkIndex,
		&i.Text,
		&i.Source,
		&i.Path,
		&i.StartLine,
		&i.EndLine,
		&i.Model,
		&i.CreatedAt,
	)
	return i, err
}

const createMemoryEmbedding = `-- name: CreateMemoryEmbedding :one


INSERT INTO memory_embeddings (chunk_id, model, dimensions, embedding)
VALUES (?, ?, ?, ?)
RETURNING id, chunk_id, model, dimensions, embedding, created_at
`

type CreateMemoryEmbeddingParams struct {
	ChunkID    sql.NullInt64 `json:"chunk_id"`
	Model      string        `json:"model"`
	Dimensions int64         `json:"dimensions"`
	Embedding  []byte        `json:"embedding"`
}

// Note: FTS queries use raw SQL in hybrid.go because sqlc doesn't support virtual tables
// Memory embeddings queries
func (q *Queries) CreateMemoryEmbedding(ctx context.Context, arg CreateMemoryEmbeddingParams) (MemoryEmbedding, error) {
	row := q.db.QueryRowContext(ctx, createMemoryEmbedding,
		arg.ChunkID,
		arg.Model,
		arg.Dimensions,
		arg.Embedding,
	)
	var i MemoryEmbedding
	err := row.Scan(
		&i.ID,
		&i.ChunkID,
		&i.Model,
		&i.Dimensions,
		&i.Embedding,
		&i.CreatedAt,
	)
	return i, err
}

const deleteEmbeddingCache = `-- name: DeleteEmbeddingCache :exec
DELETE FROM embedding_cache WHERE content_hash = ?
`

func (q *Queries) DeleteEmbeddingCache(ctx context.Context, contentHash string) error {
	_, err := q.db.ExecContext(ctx, deleteEmbeddingCache, contentHash)
	return err
}

const deleteMemoryChunks = `-- name: DeleteMemoryChunks :exec
DELETE FROM memory_chunks WHERE memory_id = ?
`

func (q *Queries) DeleteMemoryChunks(ctx context.Context, memoryID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, deleteMemoryChunks, memoryID)
	return err
}

const deleteMemoryEmbeddings = `-- name: DeleteMemoryEmbeddings :exec
DELETE FROM memory_embeddings WHERE chunk_id = ?
`

func (q *Queries) DeleteMemoryEmbeddings(ctx context.Context, chunkID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, deleteMemoryEmbeddings, chunkID)
	return err
}

const deleteMemoryEmbeddingsByModel = `-- name: DeleteMemoryEmbeddingsByModel :exec
DELETE FROM memory_embeddings WHERE model = ?
`

func (q *Queries) DeleteMemoryEmbeddingsByModel(ctx context.Context, model string) error {
	_, err := q.db.ExecContext(ctx, deleteMemoryEmbeddingsByModel, model)
	return err
}

const getEmbeddingCache = `-- name: GetEmbeddingCache :one

SELECT content_hash, embedding, model, dimensions, created_at
FROM embedding_cache
WHERE content_hash = ? AND model = ?
`

type GetEmbeddingCacheParams struct {
	ContentHash string `json:"content_hash"`
	Model       string `json:"model"`
}

// Embedding cache queries
func (q *Queries) GetEmbeddingCache(ctx context.Context, arg GetEmbeddingCacheParams) (EmbeddingCache, error) {
	row := q.db.QueryRowContext(ctx, getEmbeddingCache, arg.ContentHash, arg.Model)
	var i EmbeddingCache
	err := row.Scan(
		&i.ContentHash,
		&i.Embedding,
		&i.Model,
		&i.Dimensions,
		&i.CreatedAt,
	)
	return i, err
}

const getMemoryChunk = `-- name: GetMemoryChunk :one
SELECT id, memory_id, chunk_index, text, source, path, start_line, end_line, model, created_at
FROM memory_chunks
WHERE id = ?
`

type GetMemoryChunkRow struct {
	ID         int64          `json:"id"`
	MemoryID   sql.NullInt64  `json:"memory_id"`
	ChunkIndex int64          `json:"chunk_index"`
	Text       string         `json:"text"`
	Source     sql.NullString `json:"source"`
	Path       sql.NullString `json:"path"`
	StartLine  sql.NullInt64  `json:"start_line"`
	EndLine    sql.NullInt64  `json:"end_line"`
	Model      sql.NullString `json:"model"`
	CreatedAt  sql.NullTime   `json:"created_at"`
}

func (q *Queries) GetMemoryChunk(ctx context.Context, id int64) (GetMemoryChunkRow, error) {
	row := q.db.QueryRowContext(ctx, getMemoryChunk, id)
	var i GetMemoryChunkRow
	err := row.Scan(
		&i.ID,
		&i.MemoryID,
		&i.ChunkIndex,
		&i.Text,
		&i.Source,
		&i.Path,
		&i.StartLine,
		&i.EndLine,
		&i.Model,
		&i.CreatedAt,
	)
	return i, err
}

const getMemoryEmbedding = `-- name: GetMemoryEmbedding :one
SELECT id, chunk_id, model, dimensions, embedding, created_at
FROM memory_embeddings
WHERE chunk_id = ? AND model = ?
`

type GetMemoryEmbeddingParams struct {
	ChunkID sql.NullInt64 `json:"chunk_id"`
	Model   string        `json:"model"`
}

func (q *Queries) GetMemoryEmbedding(ctx context.Context, arg GetMemoryEmbeddingParams) (MemoryEmbedding, error) {
	row := q.db.QueryRowContext(ctx, getMemoryEmbedding, arg.ChunkID, arg.Model)
	var i MemoryEmbedding
	err := row.Scan(
		&i.ID,
		&i.ChunkID,
		&i.Model,
		&i.Dimensions,
		&i.Embedding,
		&i.CreatedAt,
	)
	return i, err
}

const listMemoryChunks = `-- name: ListMemoryChunks :many
SELECT id, memory_id, chunk_index, text, source, path, start_line, end_line, model, created_at
FROM memory_chunks
WHERE memory_id = ?
ORDER BY chunk_index
`

type ListMemoryChunksRow struct {
	ID         int64          `json:"id"`
	MemoryID   sql.NullInt64  `json:"memory_id"`
	ChunkIndex int64          `json:"chunk_index"`
	Text       string         `json:"text"`
	Source     sql.NullString `json:"source"`
	Path       sql.NullString `json:"path"`
	StartLine  sql.NullInt64  `json:"start_line"`
	EndLine    sql.NullInt64  `json:"end_line"`
	Model      sql.NullString `json:"model"`
	CreatedAt  sql.NullTime   `json:"created_at"`
}

func (q *Queries) ListMemoryChunks(ctx context.Context, memoryID sql.NullInt64) ([]ListMemoryChunksRow, error) {
	rows, err := q.db.QueryContext(ctx, listMemoryChunks, memoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMemoryChunksRow
	for rows.Next() {
		var i ListMemoryChunksRow
		if err := rows.Scan(
			&i.ID,
			&i.MemoryID,
			&i.ChunkIndex,
			&i.Text,
			&i.Source,
			&i.Path,
			&i.StartLine,
			&i.EndLine,
			&i.Model,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMemoryEmbeddingsByModel = `-- name: ListMemoryEmbeddingsByModel :many
SELECT me.id, me.chunk_id, me.model, me.dimensions, me.embedding, me.created_at,
       mc.text, mc.source, mc.path, mc.memory_id
FROM memory_embeddings me
JOIN memory_chunks mc ON mc.id = me.chunk_id
WHERE me.model = ?
ORDER BY me.id
LIMIT ? OFFSET ?
`

type ListMemoryEmbeddingsByModelParams struct {
	Model  string `json:"model"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

type ListMemoryEmbeddingsByModelRow struct {
	ID         int64          `json:"id"`
	ChunkID    sql.NullInt64  `json:"chunk_id"`
	Model      string         `json:"model"`
	Dimensions int64          `json:"dimensions"`
	Embedding  []byte         `json:"embedding"`
	CreatedAt  sql.NullTime   `json:"created_at"`
	Text       string         `json:"text"`
	Source     sql.NullString `json:"source"`
	Path       sql.NullString `json:"path"`
	MemoryID   sql.NullInt64  `json:"memory_id"`
}

func (q *Queries) ListMemoryEmbeddingsByModel(ctx context.Context, arg ListMemoryEmbeddingsByModelParams) ([]ListMemoryEmbeddingsByModelRow, error) {
	rows, err := q.db.QueryContext(ctx, listMemoryEmbeddingsByModel, arg.Model, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMemoryEmbeddingsByModelRow
	for rows.Next() {
		var i ListMemoryEmbeddingsByModelRow
		if err := rows.Scan(
			&i.ID,
			&i.ChunkID,
			&i.Model,
			&i.Dimensions,
			&i.Embedding,
			&i.CreatedAt,
			&i.Text,
			&i.Source,
			&i.Path,
			&i.MemoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertEmbeddingCache = `-- name: UpsertEmbeddingCache :exec
INSERT INTO embedding_cache (content_hash, embedding, model, dimensions, created_at)
VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(content_hash) DO UPDATE SET
    embedding = excluded.embedding,
    model = excluded.model,
    dimensions = excluded.dimensions,
    created_at = excluded.created_at
`

type UpsertEmbeddingCacheParams struct {
	ContentHash string `json:"content_hash"`
	Embedding   []byte `json:"embedding"`
	Model       string `json:"model"`
	Dimensions  int64  `json:"dimensions"`
}

func (q *Queries) UpsertEmbeddingCache(ctx context.Context, arg UpsertEmbeddingCacheParams) error {
	_, err := q.db.ExecContext(ctx, upsertEmbeddingCache,
		arg.ContentHash,
		arg.Embedding,
		arg.Model,
		arg.Dimensions,
	)
	return err
}
