// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sessions.sql

package db

import (
	"context"
	"database/sql"
)

const countSessionMessages = `-- name: CountSessionMessages :one
SELECT COUNT(*) FROM session_messages WHERE session_id = ?
`

func (q *Queries) CountSessionMessages(ctx context.Context, sessionID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSessionMessages, sessionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSession = `-- name: CreateSession :one

INSERT INTO sessions (id, name, scope, scope_id, metadata, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, unixepoch(), unixepoch())
RETURNING id, name, scope, scope_id, summary, token_count, message_count, last_compacted_at, metadata, created_at, updated_at
`

type CreateSessionParams struct {
	ID       string         `json:"id"`
	Name     sql.NullString `json:"name"`
	Scope    sql.NullString `json:"scope"`
	ScopeID  sql.NullString `json:"scope_id"`
	Metadata sql.NullString `json:"metadata"`
}

// Session queries for conversation persistence
func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, createSession,
		arg.ID,
		arg.Name,
		arg.Scope,
		arg.ScopeID,
		arg.Metadata,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Scope,
		&i.ScopeID,
		&i.Summary,
		&i.TokenCount,
		&i.MessageCount,
		&i.LastCompactedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSessionMessage = `-- name: CreateSessionMessage :one

INSERT INTO session_messages (session_id, role, content, tool_calls, tool_results, token_estimate, created_at)
VALUES (?, ?, ?, ?, ?, ?, unixepoch())
RETURNING id, session_id, role, content, tool_calls, tool_results, token_estimate, is_compacted, created_at
`

type CreateSessionMessageParams struct {
	SessionID     string         `json:"session_id"`
	Role          string         `json:"role"`
	Content       sql.NullString `json:"content"`
	ToolCalls     sql.NullString `json:"tool_calls"`
	ToolResults   sql.NullString `json:"tool_results"`
	TokenEstimate sql.NullInt64  `json:"token_estimate"`
}

// Session messages
func (q *Queries) CreateSessionMessage(ctx context.Context, arg CreateSessionMessageParams) (SessionMessage, error) {
	row := q.db.QueryRowContext(ctx, createSessionMessage,
		arg.SessionID,
		arg.Role,
		arg.Content,
		arg.ToolCalls,
		arg.ToolResults,
		arg.TokenEstimate,
	)
	var i SessionMessage
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Role,
		&i.Content,
		&i.ToolCalls,
		&i.ToolResults,
		&i.TokenEstimate,
		&i.IsCompacted,
		&i.CreatedAt,
	)
	return i, err
}

const deleteCompactedMessages = `-- name: DeleteCompactedMessages :exec
DELETE FROM session_messages
WHERE session_id = ? AND is_compacted = 1
`

func (q *Queries) DeleteCompactedMessages(ctx context.Context, sessionID string) error {
	_, err := q.db.ExecContext(ctx, deleteCompactedMessages, sessionID)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE id = ?
`

func (q *Queries) DeleteSession(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteSession, id)
	return err
}

const getNonCompactedMessages = `-- name: GetNonCompactedMessages :many
SELECT id, session_id, role, content, tool_calls, tool_results, token_estimate, is_compacted, created_at FROM session_messages
WHERE session_id = ? AND is_compacted = 0
ORDER BY created_at ASC
`

func (q *Queries) GetNonCompactedMessages(ctx context.Context, sessionID string) ([]SessionMessage, error) {
	rows, err := q.db.QueryContext(ctx, getNonCompactedMessages, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SessionMessage
	for rows.Next() {
		var i SessionMessage
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.Role,
			&i.Content,
			&i.ToolCalls,
			&i.ToolResults,
			&i.TokenEstimate,
			&i.IsCompacted,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrCreateScopedSession = `-- name: GetOrCreateScopedSession :one
INSERT INTO sessions (id, name, scope, scope_id, metadata, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, unixepoch(), unixepoch())
ON CONFLICT(scope, scope_id) DO UPDATE SET updated_at = unixepoch()
RETURNING id, name, scope, scope_id, summary, token_count, message_count, last_compacted_at, metadata, created_at, updated_at
`

type GetOrCreateScopedSessionParams struct {
	ID       string         `json:"id"`
	Name     sql.NullString `json:"name"`
	Scope    sql.NullString `json:"scope"`
	ScopeID  sql.NullString `json:"scope_id"`
	Metadata sql.NullString `json:"metadata"`
}

func (q *Queries) GetOrCreateScopedSession(ctx context.Context, arg GetOrCreateScopedSessionParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, getOrCreateScopedSession,
		arg.ID,
		arg.Name,
		arg.Scope,
		arg.ScopeID,
		arg.Metadata,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Scope,
		&i.ScopeID,
		&i.Summary,
		&i.TokenCount,
		&i.MessageCount,
		&i.LastCompactedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRecentSessionMessages = `-- name: GetRecentSessionMessages :many
SELECT id, session_id, role, content, tool_calls, tool_results, token_estimate, is_compacted, created_at FROM (
    SELECT id, session_id, role, content, tool_calls, tool_results, token_estimate, is_compacted, created_at FROM session_messages
    WHERE session_id = ?
    ORDER BY created_at DESC
    LIMIT ?
) sub ORDER BY created_at ASC
`

type GetRecentSessionMessagesParams struct {
	SessionID string `json:"session_id"`
	Limit     int64  `json:"limit"`
}

// Get last N messages for context window
func (q *Queries) GetRecentSessionMessages(ctx context.Context, arg GetRecentSessionMessagesParams) ([]SessionMessage, error) {
	rows, err := q.db.QueryContext(ctx, getRecentSessionMessages, arg.SessionID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SessionMessage
	for rows.Next() {
		var i SessionMessage
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.Role,
			&i.Content,
			&i.ToolCalls,
			&i.ToolResults,
			&i.TokenEstimate,
			&i.IsCompacted,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSession = `-- name: GetSession :one
SELECT id, name, scope, scope_id, summary, token_count, message_count, last_compacted_at, metadata, created_at, updated_at FROM sessions WHERE id = ?
`

func (q *Queries) GetSession(ctx context.Context, id string) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSession, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Scope,
		&i.ScopeID,
		&i.Summary,
		&i.TokenCount,
		&i.MessageCount,
		&i.LastCompactedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSessionByName = `-- name: GetSessionByName :one
SELECT id, name, scope, scope_id, summary, token_count, message_count, last_compacted_at, metadata, created_at, updated_at FROM sessions WHERE name = ?
`

func (q *Queries) GetSessionByName(ctx context.Context, name sql.NullString) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSessionByName, name)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Scope,
		&i.ScopeID,
		&i.Summary,
		&i.TokenCount,
		&i.MessageCount,
		&i.LastCompactedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSessionByScope = `-- name: GetSessionByScope :one
SELECT id, name, scope, scope_id, summary, token_count, message_count, last_compacted_at, metadata, created_at, updated_at FROM sessions WHERE scope = ? AND scope_id = ?
`

type GetSessionByScopeParams struct {
	Scope   sql.NullString `json:"scope"`
	ScopeID sql.NullString `json:"scope_id"`
}

func (q *Queries) GetSessionByScope(ctx context.Context, arg GetSessionByScopeParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSessionByScope, arg.Scope, arg.ScopeID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Scope,
		&i.ScopeID,
		&i.Summary,
		&i.TokenCount,
		&i.MessageCount,
		&i.LastCompactedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSessionMessageStats = `-- name: GetSessionMessageStats :one
SELECT
    COUNT(*) as message_count,
    COALESCE(SUM(token_estimate), 0) as total_tokens
FROM session_messages
WHERE session_id = ? AND is_compacted = 0
`

type GetSessionMessageStatsRow struct {
	MessageCount int64       `json:"message_count"`
	TotalTokens  interface{} `json:"total_tokens"`
}

func (q *Queries) GetSessionMessageStats(ctx context.Context, sessionID string) (GetSessionMessageStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getSessionMessageStats, sessionID)
	var i GetSessionMessageStatsRow
	err := row.Scan(&i.MessageCount, &i.TotalTokens)
	return i, err
}

const getSessionMessages = `-- name: GetSessionMessages :many
SELECT id, session_id, role, content, tool_calls, tool_results, token_estimate, is_compacted, created_at FROM session_messages
WHERE session_id = ?
ORDER BY created_at ASC
`

func (q *Queries) GetSessionMessages(ctx context.Context, sessionID string) ([]SessionMessage, error) {
	rows, err := q.db.QueryContext(ctx, getSessionMessages, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SessionMessage
	for rows.Next() {
		var i SessionMessage
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.Role,
			&i.Content,
			&i.ToolCalls,
			&i.ToolResults,
			&i.TokenEstimate,
			&i.IsCompacted,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessions = `-- name: ListSessions :many
SELECT id, name, scope, scope_id, summary, token_count, message_count, last_compacted_at, metadata, created_at, updated_at FROM sessions ORDER BY updated_at DESC LIMIT ? OFFSET ?
`

type ListSessionsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListSessions(ctx context.Context, arg ListSessionsParams) ([]Session, error) {
	rows, err := q.db.QueryContext(ctx, listSessions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Session
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Scope,
			&i.ScopeID,
			&i.Summary,
			&i.TokenCount,
			&i.MessageCount,
			&i.LastCompactedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markMessagesCompacted = `-- name: MarkMessagesCompacted :exec
UPDATE session_messages
SET is_compacted = 1
WHERE session_id = ? AND id <= ?
`

type MarkMessagesCompactedParams struct {
	SessionID string `json:"session_id"`
	ID        int64  `json:"id"`
}

func (q *Queries) MarkMessagesCompacted(ctx context.Context, arg MarkMessagesCompactedParams) error {
	_, err := q.db.ExecContext(ctx, markMessagesCompacted, arg.SessionID, arg.ID)
	return err
}

const updateSessionStats = `-- name: UpdateSessionStats :exec
UPDATE sessions
SET token_count = ?, message_count = ?, updated_at = unixepoch()
WHERE id = ?
`

type UpdateSessionStatsParams struct {
	TokenCount   sql.NullInt64 `json:"token_count"`
	MessageCount sql.NullInt64 `json:"message_count"`
	ID           string        `json:"id"`
}

func (q *Queries) UpdateSessionStats(ctx context.Context, arg UpdateSessionStatsParams) error {
	_, err := q.db.ExecContext(ctx, updateSessionStats, arg.TokenCount, arg.MessageCount, arg.ID)
	return err
}

const updateSessionSummary = `-- name: UpdateSessionSummary :exec
UPDATE sessions
SET summary = ?, last_compacted_at = unixepoch(), updated_at = unixepoch()
WHERE id = ?
`

type UpdateSessionSummaryParams struct {
	Summary sql.NullString `json:"summary"`
	ID      string         `json:"id"`
}

func (q *Queries) UpdateSessionSummary(ctx context.Context, arg UpdateSessionSummaryParams) error {
	_, err := q.db.ExecContext(ctx, updateSessionSummary, arg.Summary, arg.ID)
	return err
}
