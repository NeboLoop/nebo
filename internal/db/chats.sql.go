// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: chats.sql

package db

import (
	"context"
	"database/sql"
)

const countChatMessages = `-- name: CountChatMessages :one
SELECT COUNT(*) FROM chat_messages WHERE chat_id = ?
`

func (q *Queries) CountChatMessages(ctx context.Context, chatID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countChatMessages, chatID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countChatMessagesByChatId = `-- name: CountChatMessagesByChatId :one
SELECT COUNT(*) FROM chat_messages WHERE chat_id = ?
`

func (q *Queries) CountChatMessagesByChatId(ctx context.Context, chatID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countChatMessagesByChatId, chatID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countChats = `-- name: CountChats :one
SELECT COUNT(*) FROM chats
`

func (q *Queries) CountChats(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countChats)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createChat = `-- name: CreateChat :one

INSERT INTO chats (id, title, created_at, updated_at)
VALUES (?, ?, unixepoch(), unixepoch())
RETURNING id, title, created_at, updated_at, user_id
`

type CreateChatParams struct {
	ID    string `json:"id"`
	Title string `json:"title"`
}

// Chat queries
func (q *Queries) CreateChat(ctx context.Context, arg CreateChatParams) (Chat, error) {
	row := q.db.QueryRowContext(ctx, createChat, arg.ID, arg.Title)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
	)
	return i, err
}

const createChatMessage = `-- name: CreateChatMessage :one

INSERT INTO chat_messages (id, chat_id, role, content, metadata, created_at)
VALUES (?, ?, ?, ?, ?, unixepoch())
RETURNING id, chat_id, role, content, metadata, created_at, day_marker, tool_calls, tool_results, token_estimate
`

type CreateChatMessageParams struct {
	ID       string         `json:"id"`
	ChatID   string         `json:"chat_id"`
	Role     string         `json:"role"`
	Content  string         `json:"content"`
	Metadata sql.NullString `json:"metadata"`
}

// Chat message queries
func (q *Queries) CreateChatMessage(ctx context.Context, arg CreateChatMessageParams) (ChatMessage, error) {
	row := q.db.QueryRowContext(ctx, createChatMessage,
		arg.ID,
		arg.ChatID,
		arg.Role,
		arg.Content,
		arg.Metadata,
	)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.Role,
		&i.Content,
		&i.Metadata,
		&i.CreatedAt,
		&i.DayMarker,
		&i.ToolCalls,
		&i.ToolResults,
		&i.TokenEstimate,
	)
	return i, err
}

const createChatMessageForRunner = `-- name: CreateChatMessageForRunner :one
INSERT INTO chat_messages (id, chat_id, role, content, metadata, tool_calls, tool_results, token_estimate, day_marker, created_at)
VALUES (?, ?, ?, ?, NULL, ?, ?, ?, date('now', 'localtime'), unixepoch())
RETURNING id, chat_id, role, content, metadata, created_at, day_marker, tool_calls, tool_results, token_estimate
`

type CreateChatMessageForRunnerParams struct {
	ID            string         `json:"id"`
	ChatID        string         `json:"chat_id"`
	Role          string         `json:"role"`
	Content       string         `json:"content"`
	ToolCalls     sql.NullString `json:"tool_calls"`
	ToolResults   sql.NullString `json:"tool_results"`
	TokenEstimate sql.NullInt64  `json:"token_estimate"`
}

// Insert a message with tool_calls, tool_results, and token_estimate (used by runner/SessionManager)
func (q *Queries) CreateChatMessageForRunner(ctx context.Context, arg CreateChatMessageForRunnerParams) (ChatMessage, error) {
	row := q.db.QueryRowContext(ctx, createChatMessageForRunner,
		arg.ID,
		arg.ChatID,
		arg.Role,
		arg.Content,
		arg.ToolCalls,
		arg.ToolResults,
		arg.TokenEstimate,
	)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.Role,
		&i.Content,
		&i.Metadata,
		&i.CreatedAt,
		&i.DayMarker,
		&i.ToolCalls,
		&i.ToolResults,
		&i.TokenEstimate,
	)
	return i, err
}

const createChatMessageWithDay = `-- name: CreateChatMessageWithDay :one
INSERT INTO chat_messages (id, chat_id, role, content, metadata, day_marker, created_at)
VALUES (?, ?, ?, ?, ?, date('now', 'localtime'), unixepoch())
RETURNING id, chat_id, role, content, metadata, created_at, day_marker, tool_calls, tool_results, token_estimate
`

type CreateChatMessageWithDayParams struct {
	ID       string         `json:"id"`
	ChatID   string         `json:"chat_id"`
	Role     string         `json:"role"`
	Content  string         `json:"content"`
	Metadata sql.NullString `json:"metadata"`
}

func (q *Queries) CreateChatMessageWithDay(ctx context.Context, arg CreateChatMessageWithDayParams) (ChatMessage, error) {
	row := q.db.QueryRowContext(ctx, createChatMessageWithDay,
		arg.ID,
		arg.ChatID,
		arg.Role,
		arg.Content,
		arg.Metadata,
	)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.Role,
		&i.Content,
		&i.Metadata,
		&i.CreatedAt,
		&i.DayMarker,
		&i.ToolCalls,
		&i.ToolResults,
		&i.TokenEstimate,
	)
	return i, err
}

const deleteChat = `-- name: DeleteChat :exec
DELETE FROM chats WHERE id = ?
`

func (q *Queries) DeleteChat(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteChat, id)
	return err
}

const deleteChatMessage = `-- name: DeleteChatMessage :exec
DELETE FROM chat_messages WHERE id = ?
`

func (q *Queries) DeleteChatMessage(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteChatMessage, id)
	return err
}

const deleteChatMessagesAfter = `-- name: DeleteChatMessagesAfter :exec
DELETE FROM chat_messages
WHERE chat_id = ? AND created_at > ?
`

type DeleteChatMessagesAfterParams struct {
	ChatID    string `json:"chat_id"`
	CreatedAt int64  `json:"created_at"`
}

func (q *Queries) DeleteChatMessagesAfter(ctx context.Context, arg DeleteChatMessagesAfterParams) error {
	_, err := q.db.ExecContext(ctx, deleteChatMessagesAfter, arg.ChatID, arg.CreatedAt)
	return err
}

const deleteChatMessagesByChatId = `-- name: DeleteChatMessagesByChatId :exec
DELETE FROM chat_messages WHERE chat_id = ?
`

func (q *Queries) DeleteChatMessagesByChatId(ctx context.Context, chatID string) error {
	_, err := q.db.ExecContext(ctx, deleteChatMessagesByChatId, chatID)
	return err
}

const getChat = `-- name: GetChat :one
SELECT id, title, created_at, updated_at, user_id FROM chats WHERE id = ?
`

func (q *Queries) GetChat(ctx context.Context, id string) (Chat, error) {
	row := q.db.QueryRowContext(ctx, getChat, id)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
	)
	return i, err
}

const getChatMessage = `-- name: GetChatMessage :one
SELECT id, chat_id, role, content, metadata, created_at, day_marker, tool_calls, tool_results, token_estimate FROM chat_messages WHERE id = ?
`

func (q *Queries) GetChatMessage(ctx context.Context, id string) (ChatMessage, error) {
	row := q.db.QueryRowContext(ctx, getChatMessage, id)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.Role,
		&i.Content,
		&i.Metadata,
		&i.CreatedAt,
		&i.DayMarker,
		&i.ToolCalls,
		&i.ToolResults,
		&i.TokenEstimate,
	)
	return i, err
}

const getChatMessages = `-- name: GetChatMessages :many
SELECT id, chat_id, role, content, metadata, created_at, day_marker, tool_calls, tool_results, token_estimate FROM chat_messages
WHERE chat_id = ?
ORDER BY created_at ASC
`

func (q *Queries) GetChatMessages(ctx context.Context, chatID string) ([]ChatMessage, error) {
	rows, err := q.db.QueryContext(ctx, getChatMessages, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.Role,
			&i.Content,
			&i.Metadata,
			&i.CreatedAt,
			&i.DayMarker,
			&i.ToolCalls,
			&i.ToolResults,
			&i.TokenEstimate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatMessagesAfterTimestamp = `-- name: GetChatMessagesAfterTimestamp :many
SELECT id, chat_id, role, content, created_at
FROM chat_messages
WHERE chat_id = ? AND created_at > ? AND role IN ('user', 'assistant')
ORDER BY created_at ASC
`

type GetChatMessagesAfterTimestampParams struct {
	ChatID    string `json:"chat_id"`
	CreatedAt int64  `json:"created_at"`
}

type GetChatMessagesAfterTimestampRow struct {
	ID        string `json:"id"`
	ChatID    string `json:"chat_id"`
	Role      string `json:"role"`
	Content   string `json:"content"`
	CreatedAt int64  `json:"created_at"`
}

// Get messages after a given timestamp for embedding extraction (user and assistant only)
func (q *Queries) GetChatMessagesAfterTimestamp(ctx context.Context, arg GetChatMessagesAfterTimestampParams) ([]GetChatMessagesAfterTimestampRow, error) {
	rows, err := q.db.QueryContext(ctx, getChatMessagesAfterTimestamp, arg.ChatID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChatMessagesAfterTimestampRow
	for rows.Next() {
		var i GetChatMessagesAfterTimestampRow
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.Role,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatWithMessages = `-- name: GetChatWithMessages :many
SELECT
    c.id as chat_id,
    c.title,
    c.created_at as chat_created_at,
    c.updated_at as chat_updated_at,
    m.id as message_id,
    m.role,
    m.content,
    m.metadata,
    m.created_at as message_created_at
FROM chats c
LEFT JOIN chat_messages m ON c.id = m.chat_id
WHERE c.id = ?
ORDER BY m.created_at ASC
`

type GetChatWithMessagesRow struct {
	ChatID           string         `json:"chat_id"`
	Title            string         `json:"title"`
	ChatCreatedAt    int64          `json:"chat_created_at"`
	ChatUpdatedAt    int64          `json:"chat_updated_at"`
	MessageID        sql.NullString `json:"message_id"`
	Role             sql.NullString `json:"role"`
	Content          sql.NullString `json:"content"`
	Metadata         sql.NullString `json:"metadata"`
	MessageCreatedAt sql.NullInt64  `json:"message_created_at"`
}

func (q *Queries) GetChatWithMessages(ctx context.Context, id string) ([]GetChatWithMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getChatWithMessages, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChatWithMessagesRow
	for rows.Next() {
		var i GetChatWithMessagesRow
		if err := rows.Scan(
			&i.ChatID,
			&i.Title,
			&i.ChatCreatedAt,
			&i.ChatUpdatedAt,
			&i.MessageID,
			&i.Role,
			&i.Content,
			&i.Metadata,
			&i.MessageCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanionChatByUser = `-- name: GetCompanionChatByUser :one
SELECT id, title, created_at, updated_at, user_id FROM chats WHERE user_id = ? LIMIT 1
`

func (q *Queries) GetCompanionChatByUser(ctx context.Context, userID sql.NullString) (Chat, error) {
	row := q.db.QueryRowContext(ctx, getCompanionChatByUser, userID)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
	)
	return i, err
}

const getDaysWithMessages = `-- name: GetDaysWithMessages :many
SELECT day_marker, COUNT(*) as message_count
FROM chat_messages
WHERE chat_id = ?
GROUP BY day_marker
ORDER BY day_marker DESC
LIMIT ? OFFSET ?
`

type GetDaysWithMessagesParams struct {
	ChatID string `json:"chat_id"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

type GetDaysWithMessagesRow struct {
	DayMarker    sql.NullString `json:"day_marker"`
	MessageCount int64          `json:"message_count"`
}

func (q *Queries) GetDaysWithMessages(ctx context.Context, arg GetDaysWithMessagesParams) ([]GetDaysWithMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getDaysWithMessages, arg.ChatID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDaysWithMessagesRow
	for rows.Next() {
		var i GetDaysWithMessagesRow
		if err := rows.Scan(&i.DayMarker, &i.MessageCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesByDay = `-- name: GetMessagesByDay :many
SELECT id, chat_id, role, content, metadata, created_at, day_marker, tool_calls, tool_results, token_estimate FROM chat_messages
WHERE chat_id = ? AND day_marker = ?
ORDER BY created_at ASC
`

type GetMessagesByDayParams struct {
	ChatID    string         `json:"chat_id"`
	DayMarker sql.NullString `json:"day_marker"`
}

func (q *Queries) GetMessagesByDay(ctx context.Context, arg GetMessagesByDayParams) ([]ChatMessage, error) {
	rows, err := q.db.QueryContext(ctx, getMessagesByDay, arg.ChatID, arg.DayMarker)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.Role,
			&i.Content,
			&i.Metadata,
			&i.CreatedAt,
			&i.DayMarker,
			&i.ToolCalls,
			&i.ToolResults,
			&i.TokenEstimate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrCreateCompanionChat = `-- name: GetOrCreateCompanionChat :one

INSERT INTO chats (id, user_id, title, created_at, updated_at)
VALUES (?, ?, 'Companion', unixepoch(), unixepoch())
ON CONFLICT(user_id) DO UPDATE SET updated_at = unixepoch()
RETURNING id, title, created_at, updated_at, user_id
`

type GetOrCreateCompanionChatParams struct {
	ID     string         `json:"id"`
	UserID sql.NullString `json:"user_id"`
}

// Companion Mode queries
func (q *Queries) GetOrCreateCompanionChat(ctx context.Context, arg GetOrCreateCompanionChatParams) (Chat, error) {
	row := q.db.QueryRowContext(ctx, getOrCreateCompanionChat, arg.ID, arg.UserID)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
	)
	return i, err
}

const getRecentChatMessages = `-- name: GetRecentChatMessages :many
SELECT id, chat_id, role, content, metadata, created_at, day_marker, tool_calls, tool_results, token_estimate FROM (
    SELECT id, chat_id, role, content, metadata, created_at, day_marker, tool_calls, tool_results, token_estimate FROM chat_messages
    WHERE chat_id = ? AND role IN ('user', 'assistant')
    ORDER BY created_at DESC
    LIMIT ?
) sub ORDER BY created_at ASC
`

type GetRecentChatMessagesParams struct {
	ChatID string `json:"chat_id"`
	Limit  int64  `json:"limit"`
}

// Get last N user/assistant messages for UI display (excludes tool-role rows
// whose data is already reconstructed onto assistant messages via metadata).
func (q *Queries) GetRecentChatMessages(ctx context.Context, arg GetRecentChatMessagesParams) ([]ChatMessage, error) {
	rows, err := q.db.QueryContext(ctx, getRecentChatMessages, arg.ChatID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.Role,
			&i.Content,
			&i.Metadata,
			&i.CreatedAt,
			&i.DayMarker,
			&i.ToolCalls,
			&i.ToolResults,
			&i.TokenEstimate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentChatMessagesWithTools = `-- name: GetRecentChatMessagesWithTools :many
SELECT id, chat_id, role, content, metadata, created_at, day_marker, tool_calls, tool_results, token_estimate FROM (
    SELECT id, chat_id, role, content, metadata, created_at, day_marker, tool_calls, tool_results, token_estimate FROM chat_messages
    WHERE chat_id = ?
    ORDER BY created_at DESC
    LIMIT ?
) sub ORDER BY created_at ASC
`

type GetRecentChatMessagesWithToolsParams struct {
	ChatID string `json:"chat_id"`
	Limit  int64  `json:"limit"`
}

// Get last N messages with tool data for runner context window
func (q *Queries) GetRecentChatMessagesWithTools(ctx context.Context, arg GetRecentChatMessagesWithToolsParams) ([]ChatMessage, error) {
	rows, err := q.db.QueryContext(ctx, getRecentChatMessagesWithTools, arg.ChatID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.Role,
			&i.Content,
			&i.Metadata,
			&i.CreatedAt,
			&i.DayMarker,
			&i.ToolCalls,
			&i.ToolResults,
			&i.TokenEstimate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChats = `-- name: ListChats :many
SELECT id, title, created_at, updated_at, user_id FROM chats
ORDER BY updated_at DESC
LIMIT ? OFFSET ?
`

type ListChatsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListChats(ctx context.Context, arg ListChatsParams) ([]Chat, error) {
	rows, err := q.db.QueryContext(ctx, listChats, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chat
	for rows.Next() {
		var i Chat
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchChatMessages = `-- name: SearchChatMessages :many
SELECT id, chat_id, role, content, metadata, created_at, day_marker, tool_calls, tool_results, token_estimate FROM chat_messages
WHERE chat_id = ? AND content LIKE '%' || ? || '%'
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type SearchChatMessagesParams struct {
	ChatID  string         `json:"chat_id"`
	Column2 sql.NullString `json:"column_2"`
	Limit   int64          `json:"limit"`
	Offset  int64          `json:"offset"`
}

func (q *Queries) SearchChatMessages(ctx context.Context, arg SearchChatMessagesParams) ([]ChatMessage, error) {
	rows, err := q.db.QueryContext(ctx, searchChatMessages,
		arg.ChatID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.Role,
			&i.Content,
			&i.Metadata,
			&i.CreatedAt,
			&i.DayMarker,
			&i.ToolCalls,
			&i.ToolResults,
			&i.TokenEstimate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateChatMessageContent = `-- name: UpdateChatMessageContent :exec
UPDATE chat_messages SET content = ?, metadata = ? WHERE id = ?
`

type UpdateChatMessageContentParams struct {
	Content  string         `json:"content"`
	Metadata sql.NullString `json:"metadata"`
	ID       string         `json:"id"`
}

func (q *Queries) UpdateChatMessageContent(ctx context.Context, arg UpdateChatMessageContentParams) error {
	_, err := q.db.ExecContext(ctx, updateChatMessageContent, arg.Content, arg.Metadata, arg.ID)
	return err
}

const updateChatTimestamp = `-- name: UpdateChatTimestamp :exec
UPDATE chats SET updated_at = unixepoch()
WHERE id = ?
`

func (q *Queries) UpdateChatTimestamp(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, updateChatTimestamp, id)
	return err
}

const updateChatTitle = `-- name: UpdateChatTitle :exec
UPDATE chats SET title = ?, updated_at = unixepoch()
WHERE id = ?
`

type UpdateChatTitleParams struct {
	Title string `json:"title"`
	ID    string `json:"id"`
}

func (q *Queries) UpdateChatTitle(ctx context.Context, arg UpdateChatTitleParams) error {
	_, err := q.db.ExecContext(ctx, updateChatTitle, arg.Title, arg.ID)
	return err
}
